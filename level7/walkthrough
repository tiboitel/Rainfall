8. Le programme contient deux STRCPY ainsi que quatres mallocs dont deux chevauchent les precedents sur 4 octets. En affichant le contenue du registre EDX (printf "s", $edx) avant le call du premier strcopy on se rend conpte qu'il copie ARGV[1] dans le second malloc (0x804a018). Il fait la meme chose avc ARGV[2] dans le malloc numero 4. En placant un breakpoint juste avant le fopen on voit qu'il ouvre le fichier /home/user/levl8/.pass. Il lit le contenu du fichier puts("~~"). Si ca segfault pas comme un gros sale si un argument est vide ou si argv[1] a une taille trop grande. En gros on veut overflow pour remplacer le call de puts en call de <m> parce que la fonction susnommee fait un gros call printf des familles et les exercices precedents nous ont appris que si la fonction est pas appellee alors elle fait le cafe. En gros le premier argument se placera sur l'addresse de puts puis debordera sur buffer_2 pour ecrire l'addresse de <m>:

./level7 `python -c "print 'A' * 20 + '\x28\x99\x04\x08'"` `python -c "print '\xf4\x84\x04\x08'"`


