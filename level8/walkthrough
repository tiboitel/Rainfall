9. On lance le programme avec gdb on disas le main et on trouve l'appelle a system. Il se trouve apres une condition qui check que la valeur du registre corresond a 0x20. Avant on voit une comparaison avec une variable qui vient d'une data section (prefixe ds:). En faisant un objdump -s -j .rodata on dump la section et on voit les chaines auth, reset, service et login. On voit un call a system en 0x080486f5 on remonte au cmp precedent et on voit qu'il fait reference a un data segment. Pour voir le contenu du data segment on met un breakpoint au-dessus avec b* 0x080486c9 on affiche le contenu du registre %esi avec info registers esi et on l'afffiche avec printf "%s", addressofesi. Cela correspond au login vu precedement dans la section .rodata. On voit ensuite un test avec eax et 0x20 (32). On met un breakoint sur la lignede    0x080486e2 <+382>:	mov    0x8049aac,%eax. On affiche eax et recupere l'adresse du pointer. On doit ecrire 0x20 juste ensuite. On utilise printf "%x", *0x8049aac" pour connaitre l'adresse ou faire le padding = 0x0804a008 c'est l'adresse de l'argument de la commande auth. On y ajoute 0x20 pour savoir ou on doit ecrire le garbage. En faisant login on tombe sur 0x804a008, en faisant service t on voit 0x804a018 soit 15 caractere avant. on tente service + 15 character. On utilise login qui test eax (cmp, 0).


